---
icon: pen-to-square
date: 2022-01-01
category:
  - 面试题
---

## 题目：

1.说一下盒子模型

2.设置水平垂直居中

3.Dom常用的操作方法有哪些

4.什么是跨域

5.浏览器的存储器/浏览器本地存储/localstorage cookie session的区别

6.主流的浏览器/你用过什么浏览器/他们的浏览器内核都是什么/调没调过兼容性

7.vue2和3的生命周期

8.页面加载会触发哪几个   和   获取数据在哪个生命周期

9.v-if和v-show的区别

10.路由hash和history的区别

11.vue的路由守卫

12.程序的内存泄漏

13.闭包是什么

14.什么是防抖什么是节流

15.说一下前端优化的思路

16.svg和普通图片的区别

17.引入一个js文件是放在头部比较好还是尾部比较好？为什么

18.用过代码提交工具吗？说一下git代码提交流程

19.处理代码冲突的思路？

<br/>

## 解答：

### 1. 盒子模型

盒子模型是CSS中一个重要的概念，它描述了元素在页面中所占的空间大小。一个元素的盒子模型由内容区（content）、内边距（padding）、边框（border）和外边距（margin）组成。

- **内容区（content）**：元素实际包含的内容，如文本、图片等。
- **内边距（padding）**：内容区与边框之间的距离，可通过`padding-top`、`padding-right`、`padding-bottom`、`padding-left`分别设置四个方向的内边距，也可用`padding`统一设置。
- **边框（border）**：围绕内容区和内边距的线条，可通过`border-width`、`border-style`、`border-color`设置边框的宽度、样式和颜色。
- **外边距（margin）**：元素与其他元素之间的距离，同样可分别设置四个方向的外边距，或用`margin`统一设置。

在==标准盒模型==中，width 和 height 属性仅指定了内容区域（content box）的宽度和高度。

在==IE盒模型（==也称为怪异盒模型）中，width 和 height 包含了内容区、内边距以及边框的总宽度/高度。

```css
  box-sizing: content-box; /* 标准盒模型 */
  box-sizing: border-box;  /* IE盒模型 */
```

### 2. 设置水平垂直居中

以下是几种常见的水平垂直居中的实现方式：

1.flex布局：

2.grid布局

3.绝对定位+transform(translate)

4.绝对定位+margin

5.行内元素：水平：父元素text-align: center;垂直：父元素line-height与高度一样

#### 行内元素

水平：父元素text-align: center;

垂直：父元素line-height与高度一样

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
      .parent {
            text-align: center;
            line-height: 200px;
            height: 200px;
            background-color: #f0f0f0;
        }
    </style>
</head>

<body>
    <div class="parent">
        <span>居中内容</span>
    </div>
</body>

</html>
```

#### 块级元素

方法：子绝父相+transform和translate+top+left

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
      .parent {
            position: relative;
            height: 200px;
            background-color: #f0f0f0;
        }

      .child {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #ccc;
        }
    </style>
</head>

<body>
    <div class="parent">
        <div class="child">居中内容</div>
    </div>
</body>

</html>
```

#### Flexbox布局

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
      .parent {
            display: flex;
            justify-content: center;/* 主轴子元素居中排列 */
            align-items: center;/* 交叉轴子元素居中排列 */
            height: 200px;
            background-color: #f0f0f0;
        }

      .child {
            background-color: #ccc;
        }
    </style>
</head>

<body>
    <div class="parent">
        <div class="child">居中内容</div>
    </div>
</body>

</html>
```

### 3. DOM常用的操作方法

- **查找元素**：
  - `document.getElementById(id)`：通过元素的`id`属性查找元素。
  - `document.getElementsByTagName(tagName)`：通过标签名查找元素，返回一个 HTMLCollection。
  - `document.getElementsByClassName(className)`：通过类名查找元素，返回一个 HTMLCollection。
  - `document.querySelector(selector)`：通过 CSS 选择器查找第一个匹配的元素。
  - `document.querySelectorAll(selector)`：通过 CSS 选择器查找所有匹配的元素，返回一个 NodeList。
- **创建元素**：
  - `document.createElement(tagName)`：创建一个新的元素节点。
  - `document.createTextNode(text)`：创建一个新的文本节点。
- **插入元素**：
  - `parentNode.appendChild(newNode)`：将新节点添加到父节点的最后一个子节点之后。
  - `parentNode.insertBefore(newNode, referenceNode)`：将新节点插入到参考节点之前。
- **删除元素**：
  - `parentNode.removeChild(childNode)`：从父节点中删除指定的子节点。
- **修改元素属性**：
  - `element.setAttribute(name, value)`：设置元素的属性。
  - `element.getAttribute(name)`：获取元素的属性值。
  - `element.removeAttribute(name)`：移除元素的属性。 

### 4. 什么是跨域

跨域是指浏览器从一个域名的网页去请求另一个域名的资源时，由于浏览器的同源策略，会受到限制。同源策略是指浏览器只允许访问同源（协议、域名、端口都相同）的资源。常见的跨域场景有：

- 协议不同：如`http://example.com`和`https://example.com`。
- 域名不同：如`http://example.com`和`http://anotherdomain.com`。
- 端口不同：如`http://example.com:8080`和`http://example.com:3000`。
  解决跨域的方法有 JSONP、CORS、代理服务器等。

### 5. 浏览器的存储器/浏览器本地存储/localStorage、cookie、session的区别

- **localStorage**：
  - 用于长期存储数据，除非手动删除，否则数据不会过期。
  - 存储容量较大，一般为 5MB 左右。
  - 数据仅在浏览器本地存储，不会随 HTTP 请求发送到服务器。
- **cookie**：
  - 数据会随 HTTP 请求发送到服务器，可用于在客户端和服务器之间传递信息。
  - 存储容量较小，一般为 4KB 左右。
  - 可设置过期时间，过期后数据会自动删除。
- **sessionStorage**：
  - 数据仅在当前会话期间有效，关闭浏览器窗口后数据会自动删除。
  - 存储容量与`localStorage`类似，一般为 5MB 左右。
  - 数据仅在浏览器本地存储，不会随 HTTP 请求发送到服务器。

### 6. 主流的浏览器/你用过什么浏览器/他们的浏览器内核都是什么/调没调过兼容性

- **Chrome**：使用 Blink 内核，是目前市场占有率较高的浏览器，具有良好的性能和兼容性。
- **Firefox**：使用 Gecko 内核，开源且功能丰富，对 Web 标准的支持较好。
- **Safari**：使用 WebKit 内核，主要用于苹果设备，在移动端表现出色。
- **Edge**：早期使用 Trident（IE 内核），后来改用 Chromium 内核，与 Chrome 有较好的兼容性。
  在开发过程中，经常会遇到不同浏览器之间的兼容性问题，需要进行针对性的调试和处理，例如使用前缀、特性检测等方法。

### 7. Vue2和3的生命周期

#### Vue 2

- **beforeCreate**：实例初始化之后，数据观测和`event/watcher`事件配置之前被调用。
- **created**：实例已经创建完成之后被调用。在这一步，实例已经完成了数据观测、`property`和`method`的计算、`watch/event`事件回调。然而，挂载阶段还没有开始，`$el`属性目前不可用。
- **beforeMount**：在挂载开始之前被调用：相关的`render`函数首次被调用。
- **mounted**：`el`被新创建的`vm.$el`替换，并挂载到实例上去之后调用该钩子。
- **beforeUpdate**：数据更新时调用，发生在虚拟 DOM 打补丁之前。
- **updated**：由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。
- **beforeDestroy**：实例销毁之前调用。在这一步，实例仍然完全可用。
- **destroyed**：实例已经销毁之后调用。在这一步，所有的事件监听器和子实例都已经被销毁。

#### Vue 3

- **setup**：在创建组件实例时，初始化 props 和上下文之后，立即调用`setup`函数。这是组合式 API 的入口点。
- **onBeforeMount**：在挂载开始之前被调用，相当于 Vue 2 的`beforeMount`。
- **onMounted**：组件挂载到 DOM 后调用，相当于 Vue 2 的`mounted`。
- **onBeforeUpdate**：在数据更新导致的虚拟 DOM 重新渲染和打补丁之前调用，相当于 Vue 2 的`beforeUpdate`。
- **onUpdated**：在数据更新导致的虚拟 DOM 重新渲染和打补丁之后调用，相当于 Vue 2 的`updated`。
- **onBeforeUnmount**：在组件实例卸载之前调用，相当于 Vue 2 的`beforeDestroy`。
- **onUnmounted**：在组件实例卸载之后调用，相当于 Vue 2 的`destroyed`。
- **onErrorCaptured**：当捕获到一个来自子孙组件的错误时被调用。

### 8. 页面加载会触发哪几个和获取数据在哪个生命周期

#### 页面加载触发的生命周期钩子

- **Vue 2**：`beforeCreate`、`created`、`beforeMount`、`mounted`。
- **Vue 3**：`setup`、`onBeforeMount`、`onMounted`。

#### 获取数据的生命周期

通常在`created`或`mounted`钩子中获取数据。

- **`created`**：在实例创建完成后立即调用，此时数据观测、`property`和`method`的计算、`watch/event`事件回调都已经完成，可以进行数据的初始化和异步请求。
- **`mounted`**：在`el`被新创建的`vm.$el`替换，并挂载到实例上去之后调用，此时 DOM 已经渲染完成，可以进行一些依赖 DOM 的操作和数据获取。

### 9. v-if和v-show的区别

- **`v-if`**：是真正的条件渲染，它会根据表达式的值来决定是否渲染元素。当表达式的值为`false`时，元素会被完全移除，再次变为`true`时会重新渲染。
- **`v-show`**：只是简单地切换元素的 CSS `display`属性，元素始终会被渲染到 DOM 中，只是根据表达式的值来决定是否显示。
- **使用场景**：`v-if`有更高的切换开销，适合在运行时很少改变条件的场景；`v-show`有更高的初始渲染开销，适合频繁切换条件的场景。
- v-if优先级更高

### 10. 路由 hash和history的区别

- **hash**：
  - URL 中使用`#`来分隔，`#`后面的内容称为 hash 值，如`http://example.com/#/home`。
  - hash 值的变化不会向服务器发送请求，只会触发浏览器的`hashchange`事件。
  - 兼容性好，几乎所有浏览器都支持。
- **history**：
  - 使用 HTML5 的`History API`来实现，URL 看起来更像传统的 URL，如`http://example.com/home`。
  - 当 URL 发生变化时，会向服务器发送请求，需要服务器进行相应的配置来处理这些请求。
  - 兼容性相对较差，需要浏览器支持 HTML5 的`History API`。

### 11. Vue的路由守卫

路由守卫是 Vue Router 提供的一种机制，用于在路由切换前后进行一些验证和处理。常见的路由守卫有：

- **全局前置守卫**：使用`router.beforeEach`注册，在每次路由切换前都会执行。

```javascript
router.beforeEach((to, from, next) => {
    // 进行验证和处理
    if (to.meta.requiresAuth && !isAuthenticated()) {
        next('/login');
    } else {
        next();
    }
});
```

- **全局解析守卫**：使用`router.beforeResolve`注册，在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后调用。
- **全局后置钩子**：使用`router.afterEach`注册，在每次路由切换后执行，不接受`next`函数。

```javascript
router.afterEach((to, from) => {
    // 处理一些操作，如记录日志
});
```

- **路由独享守卫**：在路由配置中使用`beforeEnter`定义，只对当前路由生效。

```javascript
const routes = [
    {
        path: '/dashboard',
        component: Dashboard,
        beforeEnter: (to, from, next) => {
            // 进行验证和处理
            if (!isAdmin()) {
                next('/');
            } else {
                next();
            }
        }
    }
];
```

- **组件内守卫**：在组件中使用`beforeRouteEnter`、`beforeRouteUpdate`、`beforeRouteLeave`定义，用于在组件内处理路由相关的逻辑。

### 12. 程序的内存泄漏

内存泄漏是指程序在运行过程中，由于某些原因导致一些不再使用的内存无法被释放，从而造成内存占用不断增加的现象。常见的内存泄漏原因有：

- **全局变量**：在全局作用域中定义的变量，除非手动删除，否则不会被垃圾回收机制回收。
- **定时器和回调函数**：如果定时器或回调函数没有正确清除，会导致内存泄漏。
- **DOM 引用**：如果对 DOM 元素的引用没有及时释放，即使 DOM 元素已经从页面中移除，仍然会占用内存。
- **闭包**：闭包会引用外部函数的变量，导致这些变量无法被垃圾回收机制回收。

### 13. 闭包是什么？主要作用？

闭包是指有权访问另一个函数作用域中的变量的函数。即使该函数已经执行完毕，其作用域内的变量也不会被销毁，而是会被闭包所引用。闭包的主要作用有：

- **读取函数内部的变量**：可以在函数外部访问函数内部的变量。
- **让这些变量的值始终保持在内存中**：避免变量在函数执行完毕后被销毁。

```javascript
function outerFunction() {
    let count = 0;
    function innerFunction() {
        count++;
        return count;
    }
    return innerFunction;
}

const counter = outerFunction();
console.log(counter()); // 输出 1
console.log(counter()); // 输出 2
```

### 14. 什么是防抖什么是节流

- **防抖（Debounce）**：在一定时间内，只有最后一次触发事件才会执行相应的处理函数。常用于搜索框输入提示、窗口大小改变等场景。

```javascript
function debounce(func, delay) {
    let timer = null;
    return function() {
        const context = this;
        const args = arguments;
        clearTimeout(timer);
        timer = setTimeout(() => {
            func.apply(context, args);
        }, delay);
    };
}

function search() {
    console.log('搜索');
}

const debouncedSearch = debounce(search, 500);
window.addEventListener('input', debouncedSearch);
```

- **节流（Throttle）**：在一定时间内，只执行一次处理函数。常用于滚动加载、按钮点击等场景。

```javascript
function throttle(func, delay) {
    let timer = null;
    return function() {
        const context = this;
        const args = arguments;
        if (!timer) {
            func.apply(context, args);
            timer = setTimeout(() => {
                timer = null;
            }, delay);
        }
    };
}

function scrollHandler() {
    console.log('滚动');
}

const throttledScroll = throttle(scrollHandler, 500);
window.addEventListener('scroll', throttledScroll);
```

### 15. 说一下前端优化的思路

前端优化可以从多个方面入手，主要包括以下几个方面：

- **代码层面**：
  - **压缩代码**：压缩 HTML、CSS、JavaScript 代码，减少文件大小。
  - **合并文件**：将多个 CSS、JavaScript 文件合并为一个，减少 HTTP 请求。
  - **懒加载**：对于一些不必要的资源，如图片、脚本等，采用懒加载的方式，在需要时再加载。
  - **使用事件委托**：将事件绑定到父元素上，利用事件冒泡的原理，减少事件监听器的数量。
- **资源层面**：
  - **优化图片**：使用合适的图片格式，如 JPEG、PNG、WebP 等，并对图片进行压缩。
  - **使用 CDN**：将静态资源（如 CSS、JavaScript、图片等）托管到 CDN 上，提高资源加载速度。
- **性能层面**：
  - **缓存**：使用浏览器缓存、本地存储等方式，减少重复请求。
  - **优化 CSS 加载顺序**：将关键 CSS 内联到 HTML 中，减少首屏加载时间。
  - **优化 DOM 操作**：尽量减少 DOM 操作的次数，批量操作 DOM。
- **用户体验层面**：
  - **优化响应式设计**：确保页面在不同设备上都能有良好的显示效果。
  - **添加骨架屏**：在页面加载过程中，显示骨架屏，提高用户体验。

### 16. SVG和普通图片的区别

- **文件格式**：
  - **SVG**：是一种基于 XML 的矢量图形格式，==文件以文本形式存储。==
  - **普通图片**：如 JPEG、PNG 等，是基于像素的位图格式，==文件以二进制形式存储。==
- **图像质量**：
  - **SVG**：由于是矢量图形，无论放大或缩小，图像都==不会失真==，质量始终保持不变。
  - **普通图片**：是位图，放大后会出现锯齿和模糊现象。
- **文件大小**：
  - **SVG**：对于简单的图形，SVG 文件通常比较小，但对于复杂的图形，文件大小可能会较大。
  - **普通图片**：文件大小取决于图像的分辨率和颜色深度，一般来说，高分辨率和高颜色深度的图片文件较大。
- **交互性**：
  - **SVG**：可以通过 JavaScript 进行交互，实现动画、事件处理等功能。
  - **普通图片**：通常只是静态的，不具备交互性。
- **兼容性**：
  - **SVG**：现代浏览器都支持 SVG，但在一些旧版本的浏览器中可能存在兼容性问题。
  - **普通图片**：兼容性较好，几乎所有浏览器都支持。

### 17. 引入一个js文件是放在头部比较好还是尾部比较好？为什么

一般来说，将 JavaScript 文件放在尾部比较好，原因如下：

- **避免阻塞渲染**：如果将 JavaScript 文件放在头部，浏览器在解析 HTML 时会先下载并执行 JavaScript 文件，这会阻塞页面的渲染，导致页面加载时间变长。将 JavaScript 文件放在尾部，可以让页面先渲染完成，再加载和执行 JavaScript 文件，提高用户体验。
- **确保 DOM 元素已加载**：很多 JavaScript 代码需要操作 DOM 元素，如果在 DOM 元素还未加载完成时执行 JavaScript 代码，可能会导致找不到元素的错误。将 JavaScript 文件放在尾部，可以确保 DOM 元素已经加载完成，避免此类错误。

### 18. 用过代码提交工具吗？说一下git代码提交流程

Git 是一种常用的代码版本控制工具，以下是基本的 Git 代码提交流程：

1. **初始化仓库**：在项目目录下执行`git init`命令，将当前目录初始化为一个 Git 仓库。
2. **添加文件**：使用`git add`命令将需要提交的文件添加到暂存区。可以使用`git add .`将所有文件添加到暂存区。
3. **提交文件**：使用`git commit`命令将暂存区的文件提交到本地仓库。可以使用`git commit -m "提交说明"`添加提交说明。
4. **关联远程仓库**：使用`git remote add origin <远程仓库地址>`命令将本地仓库与远程仓库关联。
5. **推送代码**：使用`git push origin <分支名>`命令将本地仓库的代码推送到远程仓库。

### 19. 处理代码冲突的思路

当多人协作开发时，可能会出现代码冲突的情况，处理代码冲突的思路如下：

1. **查看冲突文件**：使用`git status`命令查看哪些文件发生了冲突。
2. **查看冲突内容**：打开冲突文件，会看到类似以下的冲突标记：

```
// 合并分支的代码
```

3. **解决冲突**：根据实际情况，选择保留当前分支的代码、合并分支的代码，或者将两者进行合并。删除冲突标记，确保文件内容正确。
4. **添加并提交修改**：使用`git add`命令将解决冲突后的文件添加到暂存区，然后使用`git commit`命令提交修改。
5. **推送代码**：使用`git push`命令将修改后的代码推送到远程仓库。